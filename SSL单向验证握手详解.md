# SSL单向验证握手详解
## SSL单向验证
握手阶段主要解决两个问题，第一个就协议算法达成一致。第二个是生成一个只有双方知道的加密密钥(对称)
密钥导出函数，在确定密钥交换算法的时候也就基本确定了密钥导出函数，大致都是根据三个输入数据得到一个输出数据作为对称密钥。
### 握手流程图
以RSA密钥交换算法为例，其流程如下所示
![](/home/liaoya/图片/SSL/SSL单向验证.png) 
### 握手步骤详解
简单来说，SSL单向验证握手总共以下几步，以密钥交换算法为RSA为例:

- `client_hello->`
	- client发出通信请求，包括以下信息，自己希望在这次通信中使用的TLS协议版本，支持的算法套件，SessionId,随机数A，支持的压缩算法等。其中TLS协议版本一般为客户端支持的最高版本，算法套件包括密钥交换算法，签名算法，对称密钥算法，摘要算法等，按照客户端的偏好，首选项在前。SessionId如果为空是申请新的对话，如果不为空则是申请恢复会话。随机数A是用于后续通信加密密钥生成。

![](/home/liaoya/图片/SSL/client_hello.PNG) 

- `<-server_hello`
	- server_hello回复内容包括选择的通信中使用的TLS协议版本，随机数B，SessionId，选择的算法套件，选择的压缩算法，扩展列表，server的证书，server_hello_done。其中随机数B是用于后续通信密钥的生成，SessionId如果是空则是正在进行新的通话握手，否则是恢复之前的会话，这个时候算法套件必须为之前选择的算法套件。server的证书一般是证书链，第一个证书为server本人证书，然后第二个证书为给server证书签名的证书，以此类推。server_hello_done则是告诉client，此次server_hello结束，因为server_hello有拓展项是可选的，有时候有有时候没有。

![](/home/liaoya/图片/SSL/server_hello.PNG) 

![](/home/liaoya/图片/SSL/certificate,serverkeyexchange,serverhellodone.PNG) 

- `client校验证书`
	- client校验从server处收到的证书，首先根据证书明文的签发者，从可信证书列表中寻找出对应者，根据第二步协商的加密算法，使用该签发者的公钥对证书中的签名摘要进行解密，然后根据第二步协商的摘要算法对证书的明文信息进行摘要，对比解密后的摘要和自行摘要，如果一致，证明了这个证书是由可信的机构签发的，证书信息没有被修改。然后从RCL或者OCSP(严格程度由client自行决定)处查询该证书是否被注销啥的，通过之后，根据证书的明文信息校验该证书是否过期，该证书的域名和当前访问的域名是否一致。
	-client校验从server接收的证书链，首先根据证书链的第一个证书(也就是server的证书)进行验证，证书上的信息包括


- `client->`
	- 如果server要求客户端发送证书进行验证，比如银行的一些网页只允许拥有证书的客户访问。在这个时候发送client证书，进行验证。
	- client根据第二步协商的算法从证书中提取到的公钥对随机数C进行加密，发送给server。
	- client根据第二步协商的协议选择密钥导出函数，根据随机数A,B,C生成对称密钥。将该密钥对之前几步消息的hash值进行加密，发送给server用于校验密钥正确，信道安全。
	- 发送消息，后续将不再明文通信。

![](/home/liaoya/图片/SSL/client_key_exchange.PNG) 
![](/home/liaoya/图片/SSL/Encrypted_Handshake_Message.PNG) 

- `<-server`
	- server用自己私钥将上一步client发送过来的加密后的随机数C进行解密，根据第二步协商的协议选择密钥导出函数，根据随机数A,B,C生成对称密钥，使用该密钥对上一步client发送过来的加密信息进行解密，然后对比自己之前几步的消息的hash值，一样说明server密钥正确，`client->server`信道安全。
	- server将自己生成的密钥对之前通信的hash值进行加密，发送给client，用于校验密钥正确，信道安全（主要防止攻击者在第一步时修改明文消息，比如删除算法套件列表中的强算法套件，提取所有上面握手步骤中信息的hash值来保证server之前收到的信息和client发送的消息是一致的，中途没有被修改过)

![](/home/liaoya/图片/SSL/server_encrypted_handshake_message.PNG) 


- `client`
	- 用自己生成的密钥解密上一步server发送过来的消息，对比之前通信的hash值，如果一样，说明client与server密钥一致，`server->client`信道安全。后续将正式通信。
### 一些细节
- 密钥协商算法怎么回事？是在哪个环节确定密钥协商算法的？怎么使用密钥协商算法的？密钥协商算法和那三个随机数有什么关联?RSA和DH有什么区别？
密钥交换算法就是生成本次通信的对称密钥的算法，在server_hello环节，server选择某个算法套件是就确定了密钥交换算法，以算法套件：TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
为例，其中TLS为TLS协议，ECDHE为密钥协商算法，ECDSA为签名算法。AES_256_GCM为后续通信使用的对称密钥算法，SHA384为摘要算法，其中TLS为此次通信的协议，然后ECDHE为密钥交换算法，ECDSA为验证证书的验证算法。SHA384为摘要算法。
当server_hello中选择这个算法套件时，就意味着使用ECDHE作为密钥协商算法，那么在server_hello之后就会直接给client发送server_key_exchange报文来发送自己的公钥，椭圆曲线名称等信息。然后client_key_exchange报文会给服务端发送自己的公钥，椭圆曲线名称等信息。然后两方计算出根据对方的公钥和自己的私钥以及椭圆曲线基点G，计算出一个坐标(x,y)，根据数学证明这个数据x双方是相等的。然后双方根据之前的client随机数A，server随机数B，计算得出的数据X通过密钥导出函数生成出一个AES_256_GCM密钥(由选择的算法套件决定)。
区别在于RSA是在握手客户端得到服务端证书公钥后发送key_exchange来发送第三个随机数，而ECDHE全程没有第三个随机数，这个随机数是通过数学方法各自计算得出的。所以RSA密钥协商算法可能会因为丢失服务器私钥而让第三方获取之前通话信息，而ECDHE则不会，只有同时丢失客户端和服务端私钥才能计算出对应的通信密钥。

- 证书链验证细节？证书链是在哪个环节给客户端的？客户端又是怎么进行验证的？
证书链是在server第一次回复client请求时，server_hello提供给client的，客户端会

- 证书上面不是有说明了签名者使用的算法，为什么这里还要说明签名算法？
证书信息上只说明了签名该证书使用的签名算法和摘要算法，没有说明该证书本身使用的签名算法。比如认证该证书的机构使用的是ECC算法生成的私钥进行签名，而服务端本身使用的是RSA算法生成的公私钥。
- 密钥交换算法，我知道RSA密钥交换算法过程是，明文交换客户端和服务端各自的随机数，然后使用服务端公钥传递客户端第三个随机数，然后通过密钥导出函数导出对称密钥。但是在握手的前两个回合，client_hello 和server_hello都没有确定算法套件，就已经互相交换了各自的随机数了，难道其他的密钥交换算法都需要各自的随机数吗？
都需要随机数，在DH系列密钥交换算法中，在计算得到数据X后，会和以上两个随机数通过密钥导出函数生成最后的通信密钥。